# 无重复最长字串
"""
给定一个字符串s ，请你找出其中不含有重复字符的最长子串的长度。
"""
"""
    解题思路在于你能不能想的到从重复出现的值的上一个开始算 因为前面最大的已经在max中了
    只要确保了这个 其实最大的就好算了  还有就是无论中间怎么更新最大的值只会在max中 一直都重复说明这就不是最大的 
    换一种说话 就是说你能不能想到出现重复字符之后 前面那个重复字符的下一个又是一个新字符串 
"""

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        start = -1    # 确保0-start要为一
        max = 0
        d = {}
        for i in range(len(s)):
            if s[i] in d and d[s[i]] > start:
                start = d[s[i]]   # 这个步骤是最重要的
                d[s[i]] = i
            else:
                d[s[i]] = i
                if i - start > max:
                    max = i - start
        return max
"""
    确实是有难度的 最难的地方是在start = d[s[i]] 
    因为假如开始出现重复的 
        那么计算的是不是上一个重复的位(的下一位到i的值)
        大于max就更新 不大于就不更新
        可能还会有疑问说 中间的怎么办 其实完全不用操心 看下图
    
    假如一直走一直走 先走到一样的更新start 那么如果碰到了 dict里面没有的那么这个时候会对比max 
    假如一直遇到一样的一直更新其实前面的最大的数量 就是在max中的  中间一直更新是不会影响最大值的
    
    总结
        其实这个一开始写最大值并不难 难的是出现重复的处理 
            start = d[s[i]]
            这个处理就是说把出现重复的索引为新的start(这个操作做完其实就是保证了子串没有重复的值的然后把字典中这个的值变为i)重点
        出现重复更新最难的就是说
            max怎么确定 上面说了start = d[s[i]] 就是保证子串中没有重复的值只要出现一个没有的话 和start比然后和max比不就是的呢
            重复出现一样的 是不是就会把前面的截掉啊 最大的值还是在max中啊 为什么前面要截掉啊(存在也没有意义)

"""

s = "abcabcbb"
a = Solution()
a.lengthOfLongestSubstring(s)