# 下一个排列
"""
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
必须原地修改，只允许使用额外常数空间。
"""
"""
    首先说一句 就是这个题得思想应该是专有的，所以要记住，
        解题思路如下（官方解题思路）：如果找一个更大得排列，那么首先一定要从后面找，往前找到那个突然变小的值，然后用后面得比它稍微大一点得值去替换它，然后再把它原来位置之后的所有值反序即可。
    如果没有这个我其实是看不懂这道题是什么意思的 知道这个也就好做了
    比如 98694653 
    目标就是 98695346  为什么是这样呢 因为会先找到突然变小的4发现4后面有一个最小的比他大的数5 调换 这些都好说
    那为什么那个突然变小的6不转呢 因为只比一次就可以了(确实是只比一次就可以了)
    即，组合出下一个更大的整数 其实明白这句话也能明白什么意思了 
"""


class Solution:
    def nextPermutation(self, nums):
        if sorted(nums, reverse=True) == nums:
            # 其实这个sorted的意思是 把列表里面的数据降序排列 如果nums已经是降序排列的话 sorted就是他自己
            # 也就是说降序排列之后还是自己的话(降序列表再降序还是自己) 那么就执行这个
            nums[:] = nums[::-1]  # 降序的话直接翻转即可
            return

        for i in range(len(nums) - 1)[::-1]:
            # range(7) =>[0,1,2,3,4,5,6] [::-1] =>[6,5,4,3,2,1,0]
            # 下面的if就是6和7比 5和6比找到小于的那个i 记录
            if nums[i] < nums[i + 1]:  # 就是要找到前一个比后一个小的数 记录这个i
                break
        for j in range(i + 1, len(nums)):  # 这个地方做的其实就是换位了
            if j == len(nums) - 1 or nums[j + 1] <= nums[i]:
                # 有个细节就是说突然变小 说明后面到i+1 是升序的 懂
                """以下面a为例子 先判断5是不是小于4 不是那么j加一 判断3是不是小于4 发现是的 那么5必然就是最小的大于他的数"""
                nums[i], nums[j] = nums[j], nums[i]  # 直接换j就可以了 666 真牛逼
                break

        nums[i + 1:] = nums[i + 1:][::-1]  # 其实这个地方就是最后位置交换后的逆序的代码
        return


"""
    总结思路 先判断是不是倒序 然后再找突然变小的索引 然后找这个索引后面的最小的比他大的数 这里面有个小技巧确实细节 因为后面到前面是升序 
    那么找到后一个小于他的 必然前一个就是最小的比他大的数 最最后就转换顺序就可了
"""

a = [9, 8, 6, 9, 4, 6, 5, 3]
b = Solution()
b.nextPermutation(a)
