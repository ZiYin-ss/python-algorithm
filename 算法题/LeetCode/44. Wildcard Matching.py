# 通配符匹配
"""
给定一个字符串(s) 和一个字符模式(p) ，实现一个支持'?'和'*'的通配符匹配。
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
两个字符串完全匹配才算匹配成功。
说明:
    s可能为空，且只包含从a-z的小写字母。
    p可能为空，且只包含从a-z的小写字母，以及字符?和*。
"""
"""
    解题思路 其实就是用动态规划来做的 就在于你能不能 想到动态规划的条件怎么写的
"""

class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        m, n = len(s), len(p)
        # 创建一个存储动态计算结果的二维数组
        dp = [[False] * (n + 1) for _ in range(m + 1)]
        # 边界条件1-空字符串互相匹配
        dp[0][0] = True
        # 边界条件2-*匹配任意字符串
        for j in range(n):
            if p[j] == '*':  # 其实就是说 p为*号 而s是任意字符的时候
                dp[0][j + 1] = True
            else:
                break
        # 开始状态转移
        for i in range(m):  # 其实是一行一行的来 也就是说 i一直是那个呗
            for j in range(n):
                if p[j] != '*':
                    dp[i + 1][j + 1] = dp[i][j] and (p[j] == '?' or s[i] == p[j])
                    # 这个地方应该不用说了把
                    # 为什么可以这样写 因为 dp[i][j] 就说明了限定条件 也就是说不需要考虑其他的 懂吗
                else:
                    dp[i + 1][j + 1] = dp[i][j + 1] or dp[i + 1][j]  # 这个*就是说 看看前面或者上面是不是匹配了 有一个匹配不就匹配了吗
        return dp[m][n]  # 返回的就是最后一个啊


"""
    匹配规律是 循环字符串 再循环匹配模式 判断匹配模式在走到每一个字符上的匹配结果怎么样
    回头看 不算难的
    其实从中可以看出两个动态规划的特点 就是说 当你的二维列表列出来之后 先注意你的 
        单独匹配的条件
            dp[i + 1][j + 1] = dp[i][j] and (p[j] == '?' or s[i] == p[j])
        然后就注意你的前置条件
            if p[j] == '*': 
                dp[0][j + 1] = True
        还需要注意的是 for循环是两个东西都for循环哦 因为最后是看最后一个和你第一个的匹配结果 然后依次类推 最后一个和你最后一个的匹配条件 注意哦  
"""

s = "cb"
p = "?a"
a = Solution()
print(a.isMatch(s, p))
