# 跳跃游戏
"""
给定一个非负整数数组nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。
"""
"""
    这道题是典型的贪心算法 其实就是 一下子走到最远的位置 继续走 看看能不能走到最后一个
"""


class Solution:
    def canJump(self, nums):
        max_i = 0  # 初始化当前能到达最远的位置
        for i, jump in enumerate(nums):  # i为当前位置，jump是当前位置的跳数
            if i <= max_i < i + jump:  # 如果当前位置能到达，并且当前位置+跳数>最远位置
                max_i = i + jump  # 更新最远能到达位置
        return max_i >= i


nums = [2, 3, 1, 1, 4]  # 输出：true
a = Solution()
print(a.canJump(nums))
"""
    以这个例子为例 索引0-->2  1-->3 2-->1 3-->1 4-->4
        走第一个的索引0 走到索引为2的地方 然后走到索引为3的地方 再走到索引为4的地方 然后再走到最后一个了  
        max_i 会不会一直走到i+索引数 只要大于最后一个i是不是就走到了
    中间可能有一个问题 就是说一开始不走到最大 而是先走一步再走最大 不是一开始最大 
    其实不是这样的  因为一开始最大的都走不到的话 你一步一步的走是不是也走不到啊
        nums = [3,2,1,0,4]  得这样理解
"""
