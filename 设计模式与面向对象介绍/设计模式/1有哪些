创建型模式
    简单工厂模式
        不直接向客户端暴露对象创建的实现细节 而是通过一个工厂类来负责创建产品类是实例
        当添加新产品时需要修改工厂类代码 违反了开闭原则
    工厂方法模式
        定义一个用于创建对象的接口(工厂接口) 让子类决定实例化那一个产品类
    抽象工厂模式
        定义一个工厂类接口 让工厂子类来创建一系列相关或相互依赖的对象
        就是每个具体的工厂都生产一套产品
    创建者模式
        将一个复杂对象的构建与他的表示分离 使得同样的构建过程可以创建不同的表示
    原型模式(用的太少)
    单例模式
        保证一个类只有一个实例 并提供一个访问它的全局访问点
        还记得当时在做Flask-News的时候 发送短信验证码的时候封装了一个单例模式


结构型模式
    适配器模式
        将一个类的接口转换成客户希望的另一个接口 适配器模式使得原本由于接口不兼容不能一起工作的那些类可以一起工作
        多继承实现
    桥模式
        将一个事物的两个维度分离 使其可以独立的变化
        抽象和实现相分离
    组合模式
        将对象组合成树形结构以表示"部分-整体"的层次结构 组合模式使得用户对单个对象和组合对象的使用具有一致性
    装饰模式
    外观模式
        为子系统中的一组接口提供一个一致的界面 外观模式定义了一个高层接口  这个接口使得这一子系统更加容易使用
    享元模式
    代理模式
        为其他对象提供一种代理以控制对这个对象的访问


行为型模式
    解释器模式
    责任链模式
        使多个对象都有机会处理请求 从而避免请求的发送者和接收者之间的耦合关系 将这些对象连成一条链 并沿着这条链传递该请求 直到有一个对象处理它为止
    命令模式 迭代器模式 中介者模式 备忘录模式
    观察者模式
        定义对象间的一种一对多的依赖关系 当一个对象的状态发生改变时 所有依赖于他的对象都得到通知并被自动更新
        观察者模式又称 "发布-订阅模式"  vue react 前端用的最多
    状态模式
    策略模式
        定义一系列算法 把他们一个个封装起来 并且使他们可相互替换 本模式使得算法可独立与使用它的客户而变化
        其实滴滴打车的时候 我们匹配车辆这个过程就是一个算法乃至几个算法
        要考虑的事情很多 时间啊 评分 距离 等等 假如这是几个算法
        但人少的时候是不是就很多车考虑的就少了假如 这是一个算法
        其实这个也是一个挺复杂的算法的 所以说这个也是策略模式 使得独立于用户而变化
    访问者模式
    模板方法模式
        定义一个操作中的算法的骨架而将一些步骤延迟到子类中 模板方法使得子类可以不改变一个算法的架构即可重写定义算法的某些特定步骤
        比如框架其实就是这样的 Django的使用是不是就是这样的 还有就是vue中的slot是不是这样的 虽然不叫算法但原理是不是一样的
        这个地方就类似于给某个地方扣下来把我们自己的粘上去 然后执行它
总结
    设计模式一般都是从简单开始的
    为高层代码服务 设计模式给底层的设计